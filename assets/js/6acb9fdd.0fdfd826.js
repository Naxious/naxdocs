"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[862],{1286:e=>{e.exports=JSON.parse('{"functions":[{"name":"Create","desc":"Creates a new typed observer with the specified name.\\n\\n```lua\\nlocal Observer = require(path.to.Observer)\\n\\nlocal events = {\\n\\t[\\"PlayerDamaged\\"] = Observer.Create(\\"PlayerDamaged\\") :: Observer.Event<Player, number>,\\n\\t[\\"MorningTime\\"] = Observer.Create(\\"MorningTime\\") :: Observer.Event<string>,\\n}\\n\\nreturn events\\n```","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"Event<T...>\\n"}],"function_type":"static","source":{"line":147,"path":"libraries/observer/Source/init.lua"}}],"properties":[],"types":[{"name":"Connection","desc":"","fields":[{"name":"Disconnect","lua_type":"(self: Connection) -> ()","desc":"Disconnects the connection, removing the callback from the event."}],"source":{"line":16,"path":"libraries/observer/Source/init.lua"}},{"name":"Event<T...>","desc":"","fields":[{"name":"Connect","lua_type":"(self: Event<T...>, callback: (...any) -> ()) -> Connection","desc":"Connects a callback to the event. The callback will be called with the event\'s parameters when the event is fired."},{"name":"Fire","lua_type":"(self: Event<T...>, ...: T...) -> ()","desc":"Fires the event with the given parameters. All connected callbacks will be called with these parameters."}],"source":{"line":27,"path":"libraries/observer/Source/init.lua"}}],"name":"Observer","desc":"- Wally Package: [Observer](https://wally.run/package/naxious/observer)\\n\\nA typed observer that notifies subscribers when its value changes.\\nObservers can be created and subscribed to from any module.\\nThey are useful for decoupling modules and creating a more modular codebase.\\nThe Observer class is a singleton and should not be instantiated.\\nThe Observer class provides two methods for creating and getting observers.\\nYou can create an observer with a specific type and subscribe to it with a callback.\\nWhen the observer\'s value changes, all subscribed callbacks are called with the new value.\\n\\nOne of my favorite explanations of the observer pattern is from [Refactoring Guru](https://refactoring.guru/design-patterns/observer).\\n\\nHere\'s an example of how to use the Observer class:\\n`Firstly, Setup Event Module`\\n```lua\\nlocal Observer = require(path.to.Observer)\\n\\nlocal events = {\\n\\t[\\"PlayerDamaged\\"] = Observer.Create(\\"PlayerDamaged\\") :: Observer.Event<Player, number>,\\n\\t[\\"MorningTime\\"] = Observer.Create(\\"MorningTime\\") :: Observer.Event<string>,\\n}\\n\\nreturn events\\n```\\n`Secondly, Connect to an Event in any Module`\\n```lua\\nlocal events = require(path.to.Events)\\n\\nevents.MorningTime:Connect(function(morningString: string)\\n\\tif morningString == \\"Good Morning\\" then\\n\\t\\tprint(`{morningString}! It\'s a awesome day!`)\\n\\telseif morningString == \\"Bad Morning\\" then\\n\\t\\tprint(`{morningString}! It\'s what we get when it rains!`)\\n\\tend\\nend)\\n\\nevents.PlayerDamaged:Connect(function(player: Player, damage: number)\\n\\tprint(`{player.Name} took {damage} damage!`)\\n\\tplayerEffects:ShakeScreen() -- example function\\n\\tparticleSystem:BloodSplatter(player.Position) -- example function\\nend)\\n```\\n`Lastly, Fire the Event Value in any Module`\\n```lua\\nlocal events = require(path.to.Events)\\n\\nevents.MorningTime:Fire(\\"Good Morning\\")\\n\\nwhile player:IsStandingInFire() do\\n\\tevents.PlayerDamaged:Fire(10)\\nend\\n```\\n\\n:::note\\n\\tObservers are client/server specific and cannot be shared between them.\\n\\tYou would need to create a separate observer for each side.\\n\\tOR create some sort of networked event system to communicate between them.\\n:::","source":{"line":100,"path":"libraries/observer/Source/init.lua"}}')}}]);